<html><head>
<meta charset='UTF-8'>
<link href='resource/bootstrap.min.css' rel='Stylesheet' type='text/css' />
<link href='resource/style.css' rel='Stylesheet' type='text/css' />
</head>
<body>
<div id='page'>
<h1 class='entry-title'>Session Notes: Life on the Bungie Farm: Fun Things to do with 180 servers and 350 processors</h1>
 <a class='url fn n profile-usercard-hover' href='https://social.msdn.microsoft.com/profile/Dan Fernandez - MSFT' target='_blank'>Dan Fernandez - MSFT</a>
<time>    2/22/2008 2:48:48 AM</time>
<hr>
<div id='content'><p><strong>Speakers: </strong>Luis Villegas, Sean Shypula from Bungie</p>  <p><strong>Distributed client/server system</strong></p>  <ul>   <li>split up, runs it in parallel </li>    <li>processes user submitted tasks in parallel </li>    <li>180 rackmounted machines 300 processes </li>    <li>can use </li>    <li></li> </ul>  <p><strong>Advantages</strong></p>  <ul>   <li>speed up time consuming tasks - (rendering goes from day to a few hours) </li>    <li>see results of work more frequently which means more iteration which enables adding more polish </li>    <li>Automates complex processes and reduces human error, ( </li>    <li>click a&#160; button and get email when job is complete </li> </ul>  <p><strong>Main processes on the farm</strong></p>  <ul>   <li>3 main </li>    <li>Binary builds - game exes and tools </li>    <li>Lightmap rendering      <ul>       <li>All of the levels static lighting is baked into the map files </li>        <li>precomputed lighting </li>        <li>baked into level files </li>     </ul>   </li>    <li>Content builds      <ul>       <li>Raw assets into monolithic level files that ship on disc </li>     </ul>   </li>    <li>Other tasks - shaper compilation, cubemap rendering, production builds of bungie.net Web site, jobs that patch machines (OS, administrative tasks) </li> </ul>  <p><strong>Bungie Farm</strong></p>  <ul>   <li>3rd iteration </li>    <li>Halo 1 - Asset process done by hand, little automation </li>    <li>Halo 2 - automated different systems and distributed complex tasks - automate binary and lightmap systems, but they were different systems </li>    <li>Halo 3 - Unified systems into a single extensible system - unify all the systems </li> </ul>  <p><strong>Achieved During Halo 3</strong></p>  <ul>   <li>Unified codebases implemented a single system that is flexible and generic </li>    <li>Unified server pools, one farm for all </li>    <li>Updated the technology to .NET (rewrote in C#), the goal there was to make it as easy as possible to develop and maintain </li> </ul>  <p><strong>What our system has done</strong></p>  <ul>   <li>50,000 jobs      <ul>       <li>11K binary builds </li>        <li>9K lightmap jobs </li>        <li>28K job of other types </li>     </ul>   </li>    <li>Huge timesaver and reduces artist/dev time </li> </ul>  <p><strong>End User experience</strong></p>  <ul>   <li>Make it as easy to use as possible, press a button and magic happens </li>    <li>Users get the result back </li> </ul>  <p><strong>Interfaces (Build)</strong></p>  <ul>   <li>Web based tools and RSS enabled </li>    <li>Build running on system, kick off new build </li>    <li>Status - shows status of each of the build configs, shows red if it fails and shows log for each build </li>    <li>Changes - would see a list of files that changed </li>    <li>Shows permachine status - Idle or not </li> </ul>  <p>&#160;</p>  <p>Random message on Bungie slides: non facete nobis calcitrare vestrum</p>  <p>Designer - Kicking off lightmap jobs from their tools</p>  <ul>   <li>Lightmap Monitor UI - View status of all maps in game whether they are up-to-date, which sections still need to be done </li> </ul>  <p>&#160;</p>  <p><strong>Architecture</strong></p>  <ul>   <li>Single system with multiple workflows </li>    <li>Plug-in based </li>    <li>Workflows divided into client/server based </li>    <li>Single centralized server, multiple client      <ul>       <li>Not peer-to-peer, just communicate with server </li>        <li>Server manages each job's state including serializing/persisting state </li>        <li>Communication is doing using SQL Server </li>     </ul>   </li> </ul>  <p><strong>Information Flow</strong></p>  <ul>   <li>Web server&gt; SQL Server&gt; controller server &gt; farm </li> </ul>  <p><strong>Binary Build site</strong></p>  <ul>   <li>Automates code compilation, automated test process </li>    <li>Create a snapshot of source tree and symbols for each build </li>    <li>Default is incremental buids (diffs) </li>    <li>continuous integration and scheduled builds      <ul>       <li>Devs do on-demand, scheduled builds are run at night </li>     </ul>   </li>    <li>Builds take 15 minutes on the farm </li> </ul>  <p><strong>Debugging improvement</strong></p>  <ul>   <li>manual process of debugging (finding/copying files before attaching to box) </li>    <li>Get rid of manual steps </li>    <li>Use Symbol Server - Debugging Tools for Windows      <ul>       <li>Symbols registered on a server, registered by the build site once all configurations finish </li>     </ul>   </li>    <li>Source Stamping (Visual Studio)      <ul>       <li>Linker setting to specify the official location of that build's source code (/SOURCEMAP)          <ul>           <li>Step through code and VS will automatically grab the code and pull it down </li>         </ul>       </li>     </ul>   </li>    <li>Engineer can attach to any box from any machine with VS installed      <ul>       <li>Correct source and symbols downloaded automatically </li>     </ul>   </li> </ul>  <p><strong>Lightmap Farm</strong></p>  <ul>   <li>[shows beautiful before/after shots] </li>    <li>Most consuming farm process </li>    <li>Lightmapper was written specifically to be run on farm      <ul>       <li>Specify a chunk of work per machine (distribute work) </li>        <li>Merge the results </li>     </ul>   </li>    <li>Simple load-balancing scheme      <ul>       <li>Each job can be configured </li>     </ul>   </li> </ul>  <p>Cubemap Farm</p>  <ul>   <li>Used for in-game reflection </li>    <li>requires to run on Xbox dev kits, expanded farm to include Xbox dev kits </li> </ul>  <p>All slides are available on bungie.net</p>  <p>&#160;</p>  <p><strong>Implementation Details</strong></p>  <ul>   <li>C# and .NET, very pleased with the decision </li>    <li>Stick with C# for tools development in the forseeable future </li> </ul>  <p><strong>.NET XML Serialization</strong></p>  <ul>   <li>Originally chose an XML Serialization scheme - ran into issues      <ul>       <li>.NET dynamically creates a DLL for each serialization type and loads its own appdomain, some A/V software could lock during serialiation calls </li>     </ul>   </li>    <li>Moved to binary serialization, faster, used less memory, consumed less DB space </li> </ul>  <p><strong>Memory Management</strong></p>  <ul>   <li>GC - Server memory could grow out of control or even cause crashes, GC would only happen under really high memory pressure, by that point slowdowns already occur      <ul>       <li>Workaround: explicit GC, be smart about it, do it right after a task is complete </li>     </ul>   </li>    <li>Bottom line: still need to keep memory usage in mind </li> </ul>  <p><strong>Plug-ins</strong></p>  <ul>   <li>Each workflow implemented as client/server plug-ins </li>    <li>Each plug-in is a DLL </li>    <li>Isolate failures to a single DLL, if job/plug-in crashes, all other jobs are unaffected      <ul>       <li>Only kept a single active job in memory at a time </li>        <li>Inactive jobs are serialized into DB </li>        <li>If there was a crash, remove the job and move on to the next one </li>     </ul>   </li> </ul>  <p><strong>SQL Messaging</strong></p>  <ul>   <li>Senders post tot a table - recipent polls table </li>    <li>Benefits      <ul>       <li>transactional, fault tolerant </li>     </ul>   </li>    <li>Drawbacks      <ul>       <li>Difficult scaling to multiple clients </li>        <li>SQL DB maintenance (if DB went down, whole farm stopped) </li>        <li>Messages aren't immediately received </li>     </ul>   </li> </ul>  <p><strong>Future Development</strong></p>  <ul>   <li>Dynamic allocation of machines for certain tasks (build/lightmap job that was a priority and needed to be rushed through) </li>    <li>Ability to restart a job from a specific point </li>    <li>Improve admin tools </li>    <li>Create a test farm </li>    <li>Extend systems to idle PCs </li>    <li>WCF - for communication - could replace SQL messaging system we have </li>    <li>WF - Workflow foundation - farm is essentially a collection of workflows </li> </ul>  <p><strong>Implementing a Distributed Farm</strong></p>  <ul>   <li>Don't need a very large farm to get benefits of automation/distribution </li>    <li>Farm Middleware packages - Starting from scratch, would consider middleware packages (didn't exist or weren't mature enough when we started) </li>    <li>Automate simple but widely used tasks, 1 or 2 PCs to run jobs, build process is a great system to start with </li>    <li>Focus on usability </li> </ul>  <p>&#160;</p>  <p>Q: How do you take advantage of multiproc machines?    <br />A: Farm code is multithreaded</p>  <p>Q: How many people oversee farm?    <br />A: It's me, takes a significant portion of my time</p>  <p>&#160;</p>  <p><strong>Final </strong>- Bungie would not have been able to ship Halo 3 at the same quality level with out the farm in place. Studio iteration time and efficiency are key.</p></div>
</div></body>
<script type='text/javascript' src='resource/jquery-1.12.1.min.js'></script>
<script type='text/javascript' src='resource/replace.js'></script>
</html>
